---
.title = "Parsing and Rendering C Code",
.date = @date("2025-07-25T00:00:00"),
.author = "Aven",
.layout = "post.shtml",
.draft = false,
.custom = {
    "git" : "aven-cfmt"
},
---

I write a lot of C code. In fact, outside of exercising and watching
movies, programming and writing about programming is all
that I regularly do. However, formatting my C source
files always felt like a chore.
None of the existing C "pretty printers" were able to produce an output
that appealed to me, so for years I have manually formatted my code.
Then, a few months ago, I finally built up the courage
to write an auto-formatter of my own.

This article covers my
experience writing [`aven-cfmt`][8], a tiny, fast, zero-dependency
C parser and renderer. It was one of the most fun and productive
three week periods my life.

**Note:** I will generally discuss the conclusion
I reached, not the full iterative implementation process. E.g. I describe
a finite state machine tokenizer that uses
`switch` statement jump tables, but the tokenizer started as a
sequence of function calls, one per token type, backtracking on failure.

## Motivation

When it comes to C source code formatting, there are three big tools
available: [clang-format][3], [astyle][4], and [indent][5]. Unfortunately for
me, all three are designed with a few standard project style guides in mind
(GNU, Google, LLVM, etc.) and provide very limited configuration beyond that.

While the [list of
options][11] available to define a style in `clang-format` seems large, it is
very C++ focused and mainly provides minor tweaks to the
built-in styles. A couple of years ago I spent many hours tinkering with my
[`.clang-format`](<$link.asset("clang-format")>) to come up
with something close to how I "manually" code. Unfortunately, having
a tool be consistently "almost right" felt worse than formatting by hand.

I like all expressions,
parenthesis, and braces to break across lines in a
consistent manner. I was able to configure `clang-format` to
break initializer lists and function
calls, definitions, and declarations in exactly the way I wanted.

```c
// lines longer than 80 columns break before initial "element", after
// each separating operator, and after final "element"
int foo(
    int param1,
    int param2,
    int param3,
    int param4,
    int param5,
    int param6,
    int param7
);

int foo(
    int param1,
    int param2,
    int param3,
    int param4,
    int param5,
    int param6,
    int param7
) {
    return param1 + param2 + param3 + param4 + param5 + param6 + param7;
}

int arr[] = {
    element1,
    element2,
    element3,
    element4,
    element5,
    element6,
    element7,
};
```

But `clang-format` broke this consistency when it came to expressions
and other parenthesised statements. For example, it refused to break the
conditional expression of an `if` statement to match the style above.

```c
// what I want (and what aven-cfmt produces)
if (
    condition_one ||
    condition_two ||
    condition_three ||
    condition_four ||
    condition_five
) {
    // body
}

// what clang-format will produce
if (condition_one || condition_two || condition_three || condition_four ||
    condition_five) {
    // body
}
```

So I had three options: switch to follow an established style guide, manually format
my code, or write an auto-formatter myself. For or a long time I chose to
stick with the second option.
This article describes how I finally made the switch to the third.

## C is hard to parse

The main reason I love C is that it's a very simple language.
One of the C11 compilers I use is written in under 10k lines of C99 code.
It seems almost paradoxical, then, that parsing an isolated C source
file might be an impossible task.

The big issue is, of course, the preprocessor. The existence of `#define`
means that identifiers and function invocations
may be replaced by arbitrary strings of tokens.
Even worse, `#include` directives search a list of paths for
files to be pasted directly into the current source,
each of which may contain more `#define` and `#include` directives.
Then there are the conditional directives (`#if`, `#else`, `#ifdef`, etc.)
which may delete subsequent sections of the source file based on the
macro values defined at the given line, which depend on the directives
evaluated at all prior lines.

### Correctness vs. simplicity and usability

As I see it, every C parser has two choices:

 1. take the include paths as input and parse using the preprocessor and full semantic analysis;
 2. assume "reasonable" preprocessor use and hueristically parse a subset of C.

Almost all source code formatters that I'm aware of choose the second option.
The first reason for this is that hueristics are quite accurate
for most source code that is practically encountered. But, in my eyes,
the most compelling reason to avoid the first option is usability.
If the formatter requires full knowledge of include paths and
compiler built-ins (including macros provided by build flags, e.g. `-D`
for `gcc`/`clang`),
then either each user's
build system must provide such information to the formatter, or
the formatter must be able to understand each user's build system.

### My subset of C

I decided to follow the core C11 standard
with the GNU inline assembly and attribute
specifier extensions. The following headings describe the modifications
I made to the phrase structure grammar in order to
parse preprocessor directives and un-preprocessed C at the same time.

**Note:** These details were ironed out
after I had written a basic tokenizer, recursive descent
expression parser, and AST renderer.

#### Macro definitions

Macro `#define A` and `#define A(...)` directives are each be parsed into a
separate AST. Each macro AST will then be rendered when the corresponding
portion of the primary AST is rendered.

A macro definiton may be followed by a single token, a type name, an
initializer list, a list of declaration specifiers, or an expression statement,
a `do` statement, or a declaration, all ommitting the terminating `;`.
The special `#` and `##` operators are also allowed in preprocessor code.

#### Macro invocations

A macro invocation is an identifier followed by an optional parenthesised parameter
list of assignment expressions and type names. Macro invocations may appear in
type names, declaration specifiers, and compound string literals. In addition, a
postfix parenthesis expression is allowed to contain type names in its parameter
list to allow type parameterised macro invocations within expressions.

#### Conditional directives

Conditional directives (`#if`, `#else`, `#endif`, `#ifdef`, etc.)
are parsed and rendered in exactly the same way as macro definitions.
In the primary translation unit AST, conditional directives are simply ignored.
Therefore a source file must be still parseable when all
preprocessor directive lines are removed. E.g. the following is invalid
according to `aven-cfmt`.

```c
#ifdef A
int foo(int n) {
#else
int bar(int n){
#endif
    // body
}
```

## Coding style

This section is intended to serve as a crash
course on how to read the `aven-cfmt` source code.
My coding style is based on a lot of trial and error with
regards to personal productivity. It is heavily inspired by the
[nullprogram blog][1] and the [Zig][2] programming language.

In short, I use unity builds (one translation unit), errors as values,
and slices (e.g. length-based strings). I also prefer to pass structs by value,
use indices over pointers ([*Programming Without Pointers*][10]),
and allocate memory from arenas ([*Enter the Arena*][9]).

I make frequent use of the following macros.

```c
// my countof is variadic to accommodate e.g. countof((T[]){ t1, t2, t3 })
// ... whether this was a good idea remains to be determined.
#define countof(...) ((sizeof(__VA_ARGS__)) / (sizeof(*(__VA_ARGS__)))

#define Optional(t) struct { \
        t value; \
        uint8_t valid; \
    }
#define unwrap(o) (assert((o).valid), (o).value)

#define Slice(t) struct { \
        t *ptr; \
        size_t len; \
    }
#define get(s, i) (s).ptr[(assert((i) < (s).len), i)]

#define List(t) struct { \
        t *ptr; \
        size_t len; \
        size_t cap; \
    }
#define list_push(l) (l).ptr[(assert((l).len < (l).cap), (l).len++)]
#define list_pop(l) (l).ptr[(assert((l).len > 0), --(l).len)]
```

There are many critiques that can be leveled at the above definitions, I
have many of my own in mind, but practically I just love working with them.
They've allowed me to be very productive
and provide fantastic debug output when I use a debugger friendly assert; see
below.
```c
#define assert(c) ((!(c)) ? __builtin_unreachable() : (void)0)
```
With `-fsanitize-trap` and `-fsanitize=unreachable`,
`__builtin_unreachable()` becomes `__builtin_trap()`. If
`get` or `list_push`/`list_pop` attempt to access an index outside the bounds
of a given slice/list, then the debugger will trap on the offending line
of code.

The other macros from [`libaven`][12] used in this article should be
self explanatory. E.g. the code below allocates a `List(int)` with `n`
capacity from the given `arena` memory.
```c
void foo(AvenArena *arena, size_t n) {
    List(int) nums = aven_arena_create_list(int, arena, n);
    // ...
}
```

## Tokenization

For tokenization I simply followed the lexical grammar in
the C11 standard. My only modification being that I used the
unified `preprocessor-number` token type from the preprocessor token
grammar, because I never needed to distinguish between different kinds of numbers.

I chose to tokenize using a finite state
machine, since they are performant and simple to write.
I also processed the entire source file into an array of tokens
prior to parsing. I initially tokenized ahead of time for simplicity,
but it ended up being the correct choice performance wise as well.
My recursive descent parser required frequent backtracking,
which would have resulted in a lot of repeated tokenization work if the
tokenizer lazily produced tokens one-at-a-time.

The code excerpts below show how the current tokenizer identifies
"preprocessor number" tokens, as well as the `.` and `...` punctuator
tokens. The class of preprocessor number tokens
includes all valid integer and floating point literals, as
well as many invalid literals.

```c
/* ... */

typedef enum {
    /* ... */
    AVEN_C_PNC_DOT,
    AVEN_C_PNC_DOT3,
    /* ... */
} AvenCPnc;

/* ... */

typedef enum {
    AVEN_C_TOKEN_TYPE_NONE = 0,
    AVEN_C_TOKEN_TYPE_INV,
    AVEN_C_TOKEN_TYPE_ID,
    AVEN_C_TOKEN_TYPE_KEY,
    AVEN_C_TOKEN_TYPE_NUM,
    AVEN_C_TOKEN_TYPE_CHR,
    AVEN_C_TOKEN_TYPE_STR,
    AVEN_C_TOKEN_TYPE_PNC,
    AVEN_C_TOKEN_TYPE_CMT,
    AVEN_C_TOKEN_TYPE_PPD,
    AVEN_C_TOKEN_TYPE_HDR,
} AvenCTokenType;

typedef struct {
    AvenCTokenType type;
    uint32_t index;
    uint32_t end;
    uint32_t trailing_lines;
} AvenCToken;
typedef Slice(AvenCToken) AvenCTokenSlice;
typedef List(AvenCToken) AvenCTokenList;

/* ... */

typedef enum {
    AVEN_C_LEX_STATE_NONE = 0,
    AVEN_C_LEX_STATE_DONE,
    /* ... */
    AVEN_C_LEX_STATE_NUM,
    AVEN_C_LEX_STATE_NUM_EXP,
    /* ... */
    AVEN_C_LEX_STATE_DOT,
    AVEN_C_LEX_STATE_DOT_DOT,
    /* ... */
} AvenCLexState;

typedef struct {
    AvenStr bytes;
    AvenCTokenList tokens;
    AvenCLexState state;
    uint32_t token_start;
    uint32_t index;
    /* ... */
} AvenCLexCtx

/* ... */

static bool aven_c_lex_step(AvenCLexCtx *ctx) {
    char c = get(ctx->bytes, ctx->index);
    switch (ctx->state) {
        case AVEN_C_LEX_STATE_NONE: {
            ctx->token_start = ctx->index;
            switch (c) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_NUM;
                    break;
                }
                /* ... */
                case '.': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_DOT;
                    break;
                }
                /* ... */
            }
            break;
        }
        /* ... */
        case AVEN_C_LEX_STATE_NUM: {
            switch (c) {
                case '0':
                /* ... */
                case '9':
                case '_':
                case '.':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'F':
                /* ... */
                case 'O':
                case 'Q':
                /* ... */
                case 'Z':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'f':
                /* ... */
                case 'o':
                case 'q':
                /* ... */
                case 'z': {
                    ctx->index += 1;
                    break;
                }
                case 'E':
                case 'P':
                case 'e':
                case 'p': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_NUM_EXP;
                    break;
                }
                default: {
                    list_push(ctx->tokens) = (AvenCToken){
                        .index = ctx->token_start,
                        .end = ctx->index,
                        .type = AVEN_C_TOKEN_TYPE_NUM,
                    };
                    ctx->state = AVEN_C_LEX_STATE_NONE;
                    break;
                }
            }
            break;
        }
        case AVEN_C_LEX_STATE_NUM_EXP: {
            switch (c) {
                case '0':
                /* ... */
                case '9':
                case '_':
                case '.':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'F':
                /* ... */
                case 'O':
                case 'Q':
                /* ... */
                case 'Z':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'f':
                /* ... */
                case 'o':
                case 'q':
                /* ... */
                case 'z': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_NUM;
                    break;
                }
                case 'E':
                case 'P':
                case 'e':
                case 'p': {
                    ctx->index += 1;
                    break;
                }
                case '+':
                case '-': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_NUM;
                    break;
                }
                default: {
                    list_push(ctx->tokens) = (AvenCToken){
                        .index = ctx->token_start,
                        .end = ctx->index,
                        .type = AVEN_C_TOKEN_TYPE_NUM,
                    };
                    ctx->state = AVEN_C_LEX_STATE_NONE;
                    break;
                }
            }
            break;
        }
        /* ... */
        case AVEN_C_LEX_STATE_DOT: {
            switch (c) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_NUM;
                    break;
                }
                case '.': {
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_DOT_DOT;
                    break;
                }
                default: {
                    list_push(ctx->tokens) = (AvenCToken){
                        .type = AVEN_C_TOKEN_TYPE_PNC,
                        .index = ctx->token_start,
                        .end = AVEN_C_PNC_DOT,
                    };
                    ctx->state = AVEN_C_LEX_STATE_NONE;
                    break;
                }
            }
            break;
        }
        case AVEN_C_LEX_STATE_DOT_DOT: {
            switch (c) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    list_push(ctx->tokens) = (AvenCToken){
                        .type = AVEN_C_TOKEN_TYPE_PNC,
                        .index = ctx->token_start,
                        .end = AVEN_C_PNC_DOT,
                    };
                    ctx->token_start = ctx->index - 1;
                    ctx->index += 1;
                    ctx->state = AVEN_C_LEX_STATE_NUM;
                    break;
                }
                case '.': {
                    ctx->index += 1;
                    list_push(ctx->tokens) = (AvenCToken){
                        .type = AVEN_C_TOKEN_TYPE_PNC,
                        .index = ctx->token_start,
                        .end = AVEN_C_PNC_DOT3,
                    };
                    ctx->state = AVEN_C_LEX_STATE_NONE;
                    break;
                }
                default: {
                    list_push(ctx->tokens) = (AvenCToken){
                        .type = AVEN_C_TOKEN_TYPE_PNC,
                        .index = ctx->token_start,
                        .end = AVEN_C_PNC_DOT,
                    };
                    ctx->token_start = ctx->index - 1;
                    list_push(ctx->tokens) = (AvenCToken){
                        .type = AVEN_C_TOKEN_TYPE_PNC,
                        .index = ctx->token_start,
                        .end = AVEN_C_PNC_DOT,
                    };
                    ctx->state = AVEN_C_LEX_STATE_NONE;
                    break;
                }
            }
            break;
        }
        /* ... */
    }
    return ctx->state == AVEN_C_LEX_STATE_DONE;
}

static AvenCTokenSet aven_c_lex(AvenStr bytes, AvenArena *arena) {
    /* ... */
    AvenCLexCtx ctx = {
        .bytes = bytes,
        .tokens = aven_arena_create_list(AvenCToken, arena, bytes.len + 2),
    };
    /* ... */
    list_push(ctx.tokens) = (AvenCToken){ .type = AVEN_C_TOKEN_TYPE_NONE };
    while(!aven_c_lex_step(&ctx)) {}
    list_push(ctx.tokens) = (AvenCToken){
        .type = AVEN_C_TOKEN_TYPE_NONE,
        .index = ctx.token_start,
        .end = ctx.token_start,
    };
    /* ... */
}

/* ... */
```

Note that a `NONE` token is inserted before and after the list of "real" tokens.
Later on, each preprocessor line will be parsed
into tokens that will be appended to the same initial list.
Placing a `NONE` token before and after each contiguous
slice of associated tokens allows each slice to be identified
from an interior index without any context.

## Parsing

I had written several recursive descent parsers in university, as
well as a Prolog interpreter using `flex` and `bison`, but that was
2016. So I decided to pick the most basic design possible and run with
it as far as I could (spoiler: it's in the finished product).

The basic idea was to walk through the array of tokens one-by-one and
build an Abstract Syntax Tree (AST) by pushing nodes to the top of
a stack. Each node would store a type `enum`, an associated
token index, and left and right child indices. Usually child indices
would point to child nodes, but for some node types they would instead
point to a slice of associated data stored in a separate stack.

The parse context would store the current token index, the current
top of the node stack, and the current top of the data stack. If
a parse step reached a point that might require backtracking, it
would save the current context index for the token slice,
node stack, and data stack. If any future parse steps failed, then
each stack top would be reset to clear all intermediate data.

To get a better idea of what I'm talking about, below is the 

```c

```

[1]: https://nullprogram.com/
[2]: https://ziglang.org/
[3]: https://clang.llvm.org/docs/ClangFormat.html
[4]: https://gitlab.com/saalen/astyle
[5]: https://www.gnu.org/software/indent/
[6]: https://ziglang.org/documentation/master/#Source-Encoding
[7]: https://go.dev/blog/gofmt
[8]: https://github.com/permutationlock/aven-cfmt
[9]: https://www.rfleury.com/p/enter-the-arena-talk
[10]: https://www.hytradboi.com/2025/05c72e39-c07e-41bc-ac40-85e8308f2917-programming-without-pointers
[11]: https://clang.llvm.org/docs/ClangFormatStyleOptions.html
[12]: https://github.com/permutationlock/libaven

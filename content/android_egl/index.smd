---
.title = "Simple Native Android APKs",
.date = @date("2025-07-25T00:00:00"),
.author = "Aven",
.layout = "post.shtml",
.draft = false,
.custom = {
	"git" : "simple_android_egl_app"
},
---

> *Is there a simple way to build Android apps using C?*

According
to the [rawdraw android][1] project, the answer is yes! But, of course, I want to
build a minimal example from scratch.
The goal of this article is to go from zero to [OpenGL ES][13] context on my
Pixel 7a phone using C and as few Android SDK command line tools as is "easily possible."

**Disclaimer:** I am a curious C programmer, not an Android developer. The last time
that I opened Android Studio was in University in 2016 when I was working on a probe
to test snow conditions.

## Requirements

We will need `zip` and `unzip` to create and unpack `.zip` archives.
We will also need a few Android SDK tools (`aapt` or `aapt2`,
`zipalign`, `apksigner`, `adb`) and
the Android NDK `clang` toolchain. The standard [SDK][15] (command line only)
and [NDK][16] distributions should come with all that
we need. Alternatively, [sdk-custom][3] and [ndk-custom][4] provide
static Linux binaries, which are useful for developing on non-standard Linux
distributions (e.g. the [musl][17] based [distro][19] I currently use).

We'll also need [OpenJDK][14] (I'd love to avoid this,
but that is an adventure for another day).
In order to install a `.apk` app on a modern Android device, it must be
signed with `apksigner`, which depends on `java`.
Moreover, we will need `keytool` from OpenJDK to generate a keystore file.

```bash
$ keytool -genkey -v -keystore mykey.keystore -alias mykey \
    -keyalg RSA -keysize 2048 -validity 10000 \
    -storepass mypassword -keypass mypassword \
    -dname "CN=example.com, OU=ID, O=Example, L=Callar, S=Morvern, C=GB"
```

Finally, we'll need the `android.jar` file for the target Android SDK version (we
will target version 35 in this article),
which can be acquired through the SDK or [downloaded
separately][5].

## Packaging an Android APK

An Android `.apk` file is just a specially structured `.zip` archive.
The core ingredients are an `AndroidManifest.xml` file,
a `resources.arsc` file, and (optionally) `res/`, `asset/`, and `lib/` directories
to store resources, assets, and native libraries, respectively. Note that the
`AndroidManifest.xml` in the `.apk` is a compiled binary, not an
XML text file.

The general build strategy will be as follows.
 1. Create a template `temp.apk` file with `aapt` (or `aapt2`)
    using an `AndroidManifest.xml` text file, an
    `icon.png` mipmap resource, and the `android.jar` file.
 2. Extract `temp.apk` into `build/` and add a `build/lib/` directory.
 3. Compile our C code into a `build/lib/aarch64/libseglapp.so` shared library
    using the NDK `clang` toolchain.
 4. Re-package the `build` directory into `temp2.apk` with `zip`.
 5. Run the `zipalign` tool on `temp2.apk` to create `seglapp.apk`.
 6. Sign `seglapp.apk` with `apksigner`.

The inital `temp.apk` will be packaged from the following `template`
directory.

```
 - template/
     - AndroidManifest.xml
     - res/
         - mipmap/
             - icon.png
```
Our example `template/AndroidManifest.xml` is shown below. Note the
minimum and target SDK version, the package name `org.seglorg`,
and the app name `seglapp`. In a real project these
would need to change to reflect the application.

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<manifest xmlns:tools="http://schemas.android.com/tools"
        xmlns:android="http://schemas.android.com/apk/res/android"
        package="org.seglorg">
	<uses-sdk android:minSdkVersion="22"
              android:targetSdkVersion="35" />
    <uses-permission android:name="android.permission.SET_RELEASE_APP"/>
    <application android:debuggable="true" android:hasCode="false"
            android:label="seglapp"
            tools:replace="android:icon,android:theme,android:allowBackup,label"
            android:icon="@mipmap/icon">
        <activity android:configChanges="keyboardHidden|orientation"
                android:label="seglapp"
                android:name="android.app.NativeActivity"
                android:exported="true">
            <meta-data android:name="android.app.lib_name"
                    android:value="seglapp"/>
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>
```

The `template/res/mipmap/icon.png` can be any square `.png` file, e.g. the [`2x2`
square from
rawdraw android](https://github.com/cnlohr/rawdrawandroid/blob/master/Sources/res/mipmap/icon.png).
Using `aapt` we may now package our
initial `.apk`.

```bash
$ aapt package -v -f  -F ./temp.apk -I ./android.jar \
    -M ./template/AndroidManifest.xml \
    -S ./template/res --target-sdk-version 35
```

To use the newer `aapt2` binary (`aapt` has been deprecated),
the process is similar, but with some extra steps as the `aapt package` command
has been split into `aapt2 compile` and `aapt2 link`.

```bash
$ mkdir ./template/compiled
$ aapt2 compile -v ./template/res/mimpmap/icon.png \
    -o ./template/compiled
$ aapt2 link -v -o ./temp.apk -I ./android.jar \
    --manifest ./template/AndroidManifest.xml \
    --target-sdk-version 35 \
    ./template/compiled/mipmap_icon.png.flat
```

We can now unpack `temp.apk` into a new `build/` directory where
we will insert our C shared library.

```bash
$ mkdir ./build
$ unzip -o temp.apk -d ./build
Archive:  ./temp.apk
  inflating: ./build/AndroidManifest.xml  
 extracting: ./build/res/mipmap/icon.png  
 extracting: ./build/resources.arsc
```

## Building a native Android library with C

The link between native code (the C shared library we will be building) and the
Java code that drives all Android applications is provided by the
Android NDK in
[`android_native_app_glue.h`](https://android.googlesource.com/platform/ndk/+/refs/heads/main/sources/android/native_app_glue/android_native_app_glue.h)
and
[`android_native_app_glue.c`](https://android.googlesource.com/platform/ndk/+/refs/heads/main/sources/android/native_app_glue/android_native_app_glue.c).
The glue exports
an `ANativeActivity_onCreate` function that will be called from Java through
the [Java Native Inteface (JNI)][21] on startup. This
function sets up a collection of callbacks that allow our C code to  respond
to events from the main Java thread(s), and then uses `pthread_create` to
initialize a C main thread and call `android_main`. It is the
`android_main` function that will serve as the C entry point into our
application.

We will copy both glue source files into a new `src` directory
and start our own `src/main.c`. To begin, we will setup event and input
handler callbacks and run a main loop that
polls the native activity.

```c
/* src/main.c */

#include <android/log.h>
#include "android_native_app_glue.h"

#define SEGL_LOG_ID "SEGL"

static void handle_cmd(struct android_app *app, int32_t cmd) {
    switch (cmd) {
        case APP_CMD_INIT_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_INIT_WINDOW"
            );
            /* app window opened or resumed, create EGL context */
            break;
        case APP_CMD_TERM_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_TERM_WINDOW"
            );
            /* app window closed or paused, release EGL context */
            break;
        case APP_CMD_DESTROY:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_DESTROY"
            );
            /* app has been closed */
            break;
        default:
            break;
    }
}

static int32_t handle_input(struct android_app *app, AInputEvent *event) {
    /* handle touch and keyboard input */
    return 0;
}

void android_main(struct android_app *app) {
    __android_log_print(ANDROID_LOG_INFO, SEGL_LOG_ID, "android_main");
    app->onAppCmd = handle_cmd;
    app->onInputEvent = handle_input;
    /* app started, perform initial setup */
    for (;;) {
        int events;
        struct android_poll_source *source;
        for (;;) {
            int res = ALooper_pollOnce(0, 0, &events, (void **)&source);
            if (res < 0) {
                break;
            }
            if (source != NULL) {
                source->process(app, source);
            }
        }
        /* update state and draw to screen */
    }
}
```

We can now build the library and re-package the `.apk`. In this article `clang`
will always refer to the binary distributed with the Android NDK.

```bash
$ mkdir -p ./build/lib/arm64-v8a
$ clang --target=aarch64-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/arm64-v8a/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ cd ./build
$ zip -D4r ../temp2.apk .
$ zip -D0r ../temp2.apk ./resources.arsc ./AndroidManifest.xml
$ cd ..
$ zipalign -v 4 ./temp2.apk ./seglapp.apk
$ apksigner sign --key-pass pass:mypassword \
    --ks-pass pass:mypassword \
    --ks mykey.keystore \
    ./seglapp.apk
```

Finally, we can install the `seglapp.apk` on an Android device.
The device in question must be connected over USB and have
[USB debugging enabled][18].

```
$ adb install seglapp.apk
```

If all went well, we should have an app named `seglapp`
on our device. It may be necessary to run `adb` under `sudo`,
or to `su` and run `adb` as root, depending on the system and user permissions.

When we open the app, we should be
met with a black screen. This makes perfect sense: we haven't drawn anything
yet. What we have done, however, is print some log messages.
The logs for everything happening on a connected device can be viewed with
`adb shell logcat`. That command will usually produce a deluge of information
which, while potentially helpful if piped to a file, is
of little use as command line output. To view only logs produced
by our code, we can use [filters][6].

```bash
adb shell logcat SEGL:I *:S
```

The `SEGL:I` filter tells `logcat` to print messages tagged with `SEGL` that
have `ANDROID_LOG_INFO` priority or higher, while the `*:S` filter silences all
other log messages. Recall that our `__android_log_print` calls used the
tag `"SEGL"`.

Try running the above `logcat` command, then opening `seglapp` on your
Android device. Look at what log messages are printed when you open, minimize,
resume, and close the application. Below is the `logcat` output I see when
I tap on the app, swipe up to minimize it, open the app again, then
manually terminate it.

```bash
$ adb shell logcat SEGL:I *:S
07-24 14:37:19.206 25465 25484 I SEGL    : android_main
07-24 14:37:19.259 25465 25484 I SEGL    : APP_CMD_INIT_WINDOW
07-24 14:37:23.308 25465 25484 I SEGL    : APP_CMD_TERM_WINDOW
07-24 14:37:25.070 25465 25484 I SEGL    : APP_CMD_INIT_WINDOW
07-24 14:37:28.058 25465 25484 I SEGL    : APP_CMD_TERM_WINDOW
07-24 14:37:28.085 25465 25484 I SEGL    : APP_CMD_DESTROY
```

## Drawing graphics with EGL and OpenGL

There are two basic directions our build could take to access to the
[EGL][12] C API: link `libEGL.so` as shared library (with `-lEGL`),
or use [`dlopen`][11] to load it runtime. I prefer to
reduce build dependencies wherever possible, so we will
be going the `dlopen` route.

```c
/* src/main.c */

#include <android/log.h>
#include <android/native_window.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <time.h>
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include "android_native_app_glue.h"

#define SEGL_LOG_ID "SEGL"
#define TIMESTEP 16L * 1000L * 1000L

struct segl_vtable {
    PFNEGLCHOOSECONFIGPROC ChooseConfig;
    PFNEGLCREATECONTEXTPROC CreateContext;
    PFNEGLCREATEWINDOWSURFACEPROC CreateWindowSurface;
    PFNEGLDESTROYCONTEXTPROC DestroyContext;
    PFNEGLDESTROYSURFACEPROC DestroySurface;
    PFNEGLGETCONFIGATTRIBPROC GetConfigAttrib;
    PFNEGLGETCURRENTDISPLAYPROC GetCurrentDisplay;
    PFNEGLGETDISPLAYPROC GetDisplay;
    PFNEGLGETPROCADDRESSPROC GetProcAddress;
    PFNEGLINITIALIZEPROC Initialize;
    PFNEGLMAKECURRENTPROC MakeCurrent;
    PFNEGLSWAPBUFFERSPROC SwapBuffers;
    PFNEGLTERMINATEPROC Terminate;
};

static struct segl_vtable segl_vtable_load(void) {
    void *so_handle = dlopen("libEGL.so", RTLD_LAZY | RTLD_LOCAL);
    if (so_handle == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            "SEGLAP",
            "failed to load libEGL.so: %s",
            dlerror()
        );
        exit(1);
    }

    struct segl_vtable vtable = { 0 };
    vtable.ChooseConfig = dlsym(so_handle, "eglChooseConfig");
    if (vtable.ChooseConfig == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglChooseConfig: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.CreateContext = dlsym(so_handle, "eglCreateContext");
    if (vtable.CreateContext == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglCreateContext: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.CreateWindowSurface = dlsym(so_handle, "eglCreateWindowSurface");
    if (vtable.CreateWindowSurface == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglCreateWindowSurf: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.DestroyContext = dlsym(so_handle, "eglDestroyContext");
    if (vtable.DestroyContext == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglDestroyContext: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.DestroySurface = dlsym(so_handle, "eglDestroySurface");
    if (vtable.DestroySurface == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglDestroySurface: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetConfigAttrib = dlsym(so_handle, "eglGetConfigAttrib");
    if (vtable.GetConfigAttrib == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetConfigAttrib: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetCurrentDisplay = dlsym(so_handle, "eglGetCurrentDisplay");
    if (vtable.GetCurrentDisplay == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetCurrentDisplay: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetDisplay = dlsym(so_handle, "eglGetDisplay");
    if (vtable.GetDisplay == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetDisplay: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetProcAddress = dlsym(so_handle, "eglGetProcAddress");
    if (vtable.GetProcAddress == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetProcAddress: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.Initialize = dlsym(so_handle, "eglInitialize");
    if (vtable.Initialize == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglInitialize: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.MakeCurrent = dlsym(so_handle, "eglMakeCurrent");
    if (vtable.MakeCurrent == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglMakeCurrent: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.SwapBuffers = dlsym(so_handle, "eglSwapBuffers");
    if (vtable.SwapBuffers == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglSwapBuffers: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.Terminate = dlsym(so_handle, "eglTerminate");
    if (vtable.Terminate == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglTerminate: %s",
            dlerror()
        );
        exit(1);
    }

    return vtable;
}

struct segl_ctx {
    EGLDisplay display;
    EGLConfig config;
    EGLContext context;
    EGLSurface surface;
};

static struct segl_ctx segl_ctx_load(
    struct android_app *app,
    struct segl_vtable *segl_vtable
) {
    struct segl_ctx segl_ctx;

    segl_ctx.display = segl_vtable->GetDisplay(EGL_DEFAULT_DISPLAY);
    if (segl_ctx.display == EGL_NO_DISPLAY) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to find EGL display"
        );
        exit(1);
    }

    EGLint major;
    EGLint minor;
    if (!segl_vtable->Initialize(segl_ctx.display, &major, &minor)) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to initialize EGL display"
        );
        exit(1);
    }

    /* NOTE: may wish to require an 8 bit alpha channel as well */
    const EGLint attribs[] = {
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_CONFORMANT, EGL_OPENGL_ES2_BIT,
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER,
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_NONE,
    };
    EGLint nconfigs;
    if (
        !segl_vtable->ChooseConfig(
            segl_ctx.display,
            attribs,
            &segl.config,
            1,
            &nconfigs
        ) ||
        nconfigs == 0
    ) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to find EGL config"
        );
        exit(1);
    }

    const EGLint context_attribs[] = {
        EGL_CONTEXT_MAJOR_VERSION, 2,
        EGL_CONTEXT_MINOR_VERSION, 0,
        EGL_NONE,
    };
    segl_ctx.context = segl_vtable->CreateContext(
        segl_ctx.display,
        segl_ctx.config,
        EGL_NO_CONTEXT,
        context_attribs
    );
    if (segl_ctx.context == EGL_NO_CONTEXT) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to create EGL context"
        );
        exit(1);
    }
    segl_ctx.surface = segl_vtable->CreateWindowSurface(
        segl_ctx.display,
        segl_ctx.config,
        app->window,
        NULL
    );
    if (segl_ctx.surface == EGL_NO_SURFACE) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to create EGL surface"
        );
        exit(1);
    }

    if (
        !segl_vtable->MakeCurrent(
            segl_ctx.display,
            segl_ctx.surface,
            segl_ctx.surface,
            segl_ctx.context
        )
    ) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to set EGL surface and context"
        );
        exit(1);
    }

    return segl_ctx;
}

static void segl_ctx_unload(
    struct segl_ctx *segl_ctx,
    struct segl_vtable *segl_vtable
) {
    if (segl_ctx->display == EGL_NO_DISPLAY) {
        return;
    }

    segl_vtable->MakeCurrent(
        segl_ctx->display,
        EGL_NO_SURFACE,
        EGL_NO_SURFACE,
        EGL_NO_CONTEXT
    );

    if (segl_ctx->context != EGL_NO_CONTEXT) {
        segl_vtable->DestroyContext(segl_ctx->display, segl_ctx->context);
    }

    if (segl_ctx->surface != EGL_NO_SURFACE) {
        segl_vtable->DestroySurface(segl_ctx->display, segl_ctx->surface);
    }

    segl_vtable->Terminate(segl_ctx->display);

    segl_ctx->display = EGL_NO_DISPLAY;
    segl_ctx->context = EGL_NO_CONTEXT;
    segl_ctx->surface = EGL_NO_SURFACE;
}

struct sgles2_vtable {
    PFNGLCLEARPROC Clear;
    PFNGLCLEARCOLORPROC ClearColor;
    PFNGLVIEWPORTPROC Viewport;
};

static struct sgles2_vtable sgles2_vtable_load(struct segl_vtable *segl_vtable) {
    struct sgles2_vtable vtable = { 0 };

    vtable.Clear = (PFNGLCLEARPROC)segl_vtable->GetProcAddress("glClear");
    if (vtable.Clear == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load glClear"
        );
        exit(1);
    }
    vtable.ClearColor = (PFNGLCLEARCOLORPROC)segl_vtable->GetProcAddress(
        "glClearColor"
    );
    if (vtable.ClearColor == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load glClearColor"
        );
        exit(1);
    }
    vtable.Viewport = (PFNGLVIEWPORTPROC)segl_vtable->GetProcAddress(
        "glViewport"
    );
    if (vtable.Viewport == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load glViewport"
        );
        exit(1);
    }

    return vtable;
}

static struct segl_vtable egl;
static struct segl_ctx egl_ctx;
static struct sgles2_vtable gl;

static void handle_cmd(struct android_app *app, int32_t cmd) {
    switch (cmd) {
        case APP_CMD_INIT_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_INIT_WINDOW"
            );
            if (egl_ctx.display != EGL_NO_DISPLAY) {
                break;
            }
            egl_ctx = segl_ctx_load(app, &egl);
            break;
        case APP_CMD_TERM_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_TERM_WINDOW"
            );
            if (egl_ctx.display == EGL_NO_DISPLAY) {
                break;
            }
            segl_ctx_unload(&egl_ctx, &egl);
            break;
        case APP_CMD_DESTROY:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_DESTROY"
            );
            /* app has been closed */
            break;
        default:
            break;
    }
}

static int32_t handle_input(struct android_app *app, AInputEvent *event) {
    /* handle touch and keyboard input */
    return 0;
}

static int64_t time_since_ns(struct timespec end, struct timespec start) {
    int64_t seconds = (int64_t)end.tv_sec - (int64_t)start.tv_sec;
    int64_t sec_diff = seconds * 1000L * 1000L * 1000L;
    int64_t nsec_diff = (int64_t)end.tv_nsec - (int64_t)start.tv_nsec;
    return sec_diff + nsec_diff;
}

void android_main(struct android_app *app) {
    __android_log_print(ANDROID_LOG_INFO, SEGL_LOG_ID, "android_main");
    app->onAppCmd = handle_cmd;
    app->onInputEvent = handle_input;

    egl = segl_vtable_load();
    gl = sgles2_vtable_load(&egl);

    float red = 0.66f;
    bool red_flip = false;
    float green = 0.33f;
    bool green_flip = false;
    float blue = 0.0f;
    bool blue_flip = false;

    int64_t elapsed = 0;
    struct timespec last;
    clock_gettime(CLOCK_MONOTONIC, &last);
    for (;;) {
        struct timespec now;
        clock_gettime(CLOCK_MONOTONIC, &now);
        elapsed += time_since_ns(now, last);
        last = now;

        while (elapsed >= TIMESTEP) {
            red += 0.005f;
            green += 0.006f;
            blue += 0.007f;
            if (red >= 1.0f) {
                red -= 1.0f;
                red_flip = !red_flip;
            }
            if (green >= 1.0f) {
                green -= 1.0f;
                green_flip = !green_flip;
            }
            if (blue >= 1.0f) {
                blue -= 1.0f;
                blue_flip = !blue_flip;
            }
            elapsed -= TIMESTEP;
        }

        int events;
        struct android_poll_source *source;
        for (;;) {
            int res = ALooper_pollOnce(0, 0, &events, (void **)&source);
            if (res < 0) {
                break;
            }
            if (source != NULL) {
                source->process(app, source);
            }
        }

        if (egl_ctx.display == EGL_NO_DISPLAY) {
            const struct timespec duration = { .tv_nsec = TIMESTEP };
            nanosleep(&duration, NULL);
            continue;
        }

        int width = ANativeWindow_getWidth(app->window);
        int height = ANativeWindow_getHeight(app->window);

        gl.Viewport(0, 0, width, height);
        gl.ClearColor(
            red_flip ? 1.0f - red : red,
            green_flip ? 1.0f - green : green,
            blue_flip ? 1.0f - blue : blue,
            1.0f
        );
        gl.Clear(GL_COLOR_BUFFER_BIT);

        egl.SwapBuffers(egl_ctx.display, egl_ctx.surface);
    }
}
```

The `segl_vtable_load` function loads `libEGL.so`, then constructs a
[vtable][20]
containing each EGL 1.0 API function needed for this demo.
The `segl_ctx_load` function
uses the EGL vtable to create an OpenGL ES 2.0 context and
an EGL window surface corresponding to the Android app window.
The `segl_ctx_unload` function destroys the EGL context and
surface.

In order to draw anything, we'll need to load a second
vtable containing some OpenGL functions.
The `sgles2_vtable_load` function loads such
a table, using the EGL vtable's `GetProcAddress`
to retrieve each function pointer.

The loop in `android_main` clears the screen with a varying color.
The `handle_cmd` function loads an EGL context on
`APP_CMD_INIT_WINDOW` events and destroys the context
on `APP_CMD_TERM_WINDOW` events.

**Note:** In a real project you should probably load the
full EGL 1.0 and OpenGL ES 2.0 APIs (or
whichever API versions you decide to use).

Going through the same process as before, we can
compile our shared library, re-package `seglapp.apk`, and install
it on our device.

```bash
$ adb uninstall org.seglorg.seglapp
$ rm temp2.apk seglapp.apk
$ clang --target=aarch64-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/arm64-v8a/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ cd ./build
$ zip -D4r ../temp2.apk .
$ zip -D0r ../temp2.apk ./resources.arsc ./AndroidManifest.xml
$ cd ..
$ zipalign -v 4 ./temp2.apk ./seglapp.apk
$ apksigner sign --key-pass pass:mypassword \
    --ks-pass pass:mypassword \
    --ks mykey.keystore \
    ./seglapp.apk
$ adb install seglapp.apk
```

Running `seglapp` should now display a varying solid color
background which can be seemlessly suspended and resumed.

## Multi-architecture builds

The `seglapp.apk` we packaged above will only work on 64 bit ARM devices.
Fortunately, the process to package a `.apk` for multiple architectures
is very simple: add a separate subdirectory in `build/lib` for
each architecture! For example, below
we add support for 32 bit ARM, x86, and x86_64.

```bash
$ mkdir -p ./build/lib/armeabi-v7a
$ clang --target=armv7a-linux-androideabi22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/armeabi-v7a/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ mkdir -p ./build/lib/x86
$ clang --target=i686-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/x86/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ mkdir -p ./build/lib/x86_64
$ clang --target=x86_64-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/x86_64/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
# then proceed with re-packaging as usual
```

## Next steps

Our OpenGL example was very dissapointing, we didn't even draw a triangle!
Loading the rest of the OpenGL ES API into the vtable, adding a basic
shader pipeline, and pushing some vertices to the GPU
should be priority number one.

We also haven't handled any input in our `handle_input` function,
the next step there is to
look at the Android NDK [input documentation][7].
We used the `ANativeWindow` API to get the width and height of the
application window, but there is [a lot more functionality available][10].
There are also a
few more `APP_CMD` events that may be useful, so it might be good
to read through the [native app glue docs][8] as well (and look
through the `android_native_app_glue.c` source file).

A finished version of the example in this article is available on [GitHub][9].

[1]: https://github.com/cnlohr/rawdrawandroid
[2]: https://github.com/permutationlock/libavengraph
[3]: https://github.com/HomuHomu833/android-sdk-custom
[4]: https://github.com/HomuHomu833/android-ndk-custom
[5]: https://github.com/Sable/android-platforms
[6]: https://developer.android.com/tools/logcat#filteringOutput
[7]: https://developer.android.com/ndk/reference/group/input
[8]: https://developer.android.com/reference/games/game-activity/group/android-native-app-glue
[9]: https://github.com/permutationlock/simple_android_egl_app
[10]: https://developer.android.com/ndk/reference/group/native-activity
[11]: https://www.man7.org/linux/man-pages/man3/dlopen.3.html
[12]: https://www.khronos.org/egl/
[13]: https://www.khronos.org/opengles/
[14]: https://openjdk.org/index.html
[15]: https://developer.android.com/studio
[16]: https://developer.android.com/ndk/downloads
[17]: https://musl.libc.org/
[18]: https://developer.android.com/studio/debug/dev-options
[19]: https://chimera-linux.org/
[20]: https://en.wikipedia.org/wiki/Virtual_method_table
[21]: https://en.wikipedia.org/wiki/Java_Native_Interface

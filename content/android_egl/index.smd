---
.title = "Simple Android Apps in C",
.date = @date("2025-07-25T00:00:00"),
.author = "Aven",
.layout = "post.shtml",
.draft = false,
.custom = {
	"git" : "simple_android_egl_app"
},
---

> *Is there a simple way to build Android apps using C?*

The [rawdraw android][1] project shows that the answer is yes! But I want to
break the process down even further and
construct a minimal example from scratch.
The goal of this article is to go from zero to [OpenGL ES][13] context on my
Pixel 7a phone using C and command-line tools.

**Disclaimer:** By most people's definition, the *simple* way to build an app
with C is probably to use [Android Studio][15].
Simple in this article, however, means having few dependencies and build steps.

## Build environment

This article assumes that we are working in a shell on a
Unix/POSIX-like operating system (e.g. `bash` on Linux). The
Android command-line tools are the same on Windows though,
so with a bit of work translating POSIX commands it is
possible to follow along from PowerShell (I've done it myself).

### OpenJDK

We will need [OpenJDK][14] for `java` and `keytool`. Preferably,
we can install OpenJDK through our system package manager. Otherwise,
if a [distribution is available][27] for our CPU architecture and OS, then we
can pull a local copy as shown below. If not, there are
[instructions][28] to build the JDK from [source][32].

```bash
$ curl <release-url-for-your-arch-os> \
    -o openjdk24.tar.gz
$ tar -xvf openjdk24.tar.gz
$ export JAVA_HOME=/path/to/jdk-24.0.2
$ export PATH="/path/to/jdk-24.0.2/bin:$PATH"
```

We have to add the `jdk-24.0.2/bin` directory to our `PATH` because
the Android SDK `apksigner` script expects a `java` command.

### Android tools

The Android specific tools we'll be using are `aapt` (or `aapt2`),
`zipalign`, and `apksigner` from the SDK build-tools,
`adb` from the SDK platform-tools, and
the `clang` tool-chain from the NDK.

#### The official way

If we are on a standard GNU Linux distribution, MacOS, or Windows,
we can download and unpack the official [Android Studio][15] "command-line
tools only" distribution.
The [`sdkmanager`][26] can then be used to install the SDK build-tools,
platforms, and platform-tools, as well as the [NDK][16].

```bash
$ curl <release-url-for-your-arch-os> \
    -o cmdline-tools.zip
$ mkdir android_sdk
$ unzip cmdline-tools.zip -d ./android_sdk/
$ ./android_sdk/cmdline-tools/bin/sdkmanager --sdk-root ./android_sdk \
    "build-tools;35.0.1" \
    "platforms;android-35" \
    "platform-tools" \
    "ndk;29.0.13599879"
```

All the files we need should now be installed.

```
./android_sdk/build-tools/35.0.1/aapt
./android_sdk/build-tools/35.0.1/apksigner
./android_sdk/build-tools/35.0.1/zipalign
./android_sdk/platform-tools/adb
./android_sdk/platforms/android-35/android.jar
./android_sdk/ndk/29.0.13599879/toolchains/llvm/prebuilt/<os>-<arch>/bin/clang
```

For brevity, and to accommodate different installations, from now on we will
omit the full path and refer to each of the above by file name.
Optionally, we can add each relevant directory our `PATH`.

#### A static alternative for Linux

If we are on a non-standard Linux
distribution, e.g. the [musl][17]-based [distro][19] I primarily use,
then the official binary distribution may not work.
The [sdk-custom][3] and [ndk-custom][4] GitHub pages provide
static Linux binary releases for the Android SDK build-tools,
platform-tools, and the Android NDK.

We'll still need the `android.jar` file for the Android SDK platform,
but that can be downloaded from the [official repo][25] or the third
party [Sable collection][5].

#### Building from source

If all else fails, everything in the SDK and NDK is open source,
split across [several repos][24].
I have not tried to build the tools myself yet, but the
[sdk-custom][3] and [ndk-custom][4]
projects mentioned above look like a useful resource.

## Packaging an Android APK

An Android `.apk` file is just a specially structured `.zip` archive.
The core ingredients are an `AndroidManifest.xml` file,
a `resources.arsc` file, and (optionally) `res/`, `asset/`, and `lib/` directories
to store resources, assets, and native libraries, respectively. Note that the
`AndroidManifest.xml` in the `.apk` is a compiled binary, not an
XML text file.

The general build strategy will be as follows.
 1. Create a template `temp.apk` file with `aapt` (or `aapt2`)
    using an `AndroidManifest.xml` text file, an
    `icon.png` mipmap resource, and the `android.jar` file.
 2. Extract `temp.apk` into `build/` and add a `build/lib/` directory.
 3. Compile our C code into a `build/lib/aarch64/libseglapp.so` shared library.
 4. Re-package the `build/` directory into `temp2.apk` with `zip`.
 5. Run the `zipalign` tool on `temp2.apk` to create `seglapp.apk`.
 6. Sign `seglapp.apk` with `apksigner`.

To package the initial `temp.apk`, we will first create a `template/`
directory that is structured as follows.

```
 - template/
     - AndroidManifest.xml
     - res/
         - mipmap/
             - icon.png
```

Our `template/AndroidManifest.xml` is shown below. Note the
minimum and target SDK version (22 and 35), the package name (`org.seglorg`),
and the app name (`seglapp`). In a real project these
would need to reflect the given application, see the
[app manifest documentation][29].

```xml
<!-- template/AndroidManifest.xml -->

<?xml version="1.0" encoding="utf-8" standalone="no"?>
<manifest xmlns:tools="http://schemas.android.com/tools"
        xmlns:android="http://schemas.android.com/apk/res/android"
        package="org.seglorg">
	<uses-sdk android:minSdkVersion="22"
              android:targetSdkVersion="35" />
    <uses-permission android:name="android.permission.SET_RELEASE_APP"/>
    <application android:debuggable="true" android:hasCode="false"
            android:label="seglapp"
            tools:replace="android:icon,android:theme,android:allowBackup,label"
            android:icon="@mipmap/icon">
        <activity android:configChanges="keyboardHidden|orientation"
                android:label="seglapp"
                android:name="android.app.NativeActivity"
                android:exported="true">
            <meta-data android:name="android.app.lib_name"
                    android:value="seglapp"/>
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>
```

The `template/res/mipmap/icon.png` can be any square `.png` file, e.g. the [`2x2`
square from
rawdraw android](https://github.com/cnlohr/rawdrawandroid/blob/master/Sources/res/mipmap/icon.png).
Using `aapt` we may now package our
initial `.apk`.

```bash
$ aapt package -v -f  -F ./temp.apk -I android.jar \
    -M ./template/AndroidManifest.xml \
    -S ./template/res --target-sdk-version 35
```

To use the newer [`aapt2`][33] binary (`aapt` has been deprecated),
the process is similar, but with some extra steps. The `aapt package` command
has been split into `aapt2 compile` and `aapt2 link`.

```bash
$ mkdir ./template/compiled
$ aapt2 compile -v ./template/res/mimpmap/icon.png \
    -o ./template/compiled
$ aapt2 link -v -o ./temp.apk -I android.jar \
    --manifest ./template/AndroidManifest.xml \
    --target-sdk-version 35 \
    ./template/compiled/mipmap_icon.png.flat
```

We can now unpack `temp.apk` into a new `build/` directory where
we will insert our C shared library.

```bash
$ mkdir ./build
$ unzip -o temp.apk -d ./build
Archive:  ./temp.apk
  inflating: ./build/AndroidManifest.xml  
 extracting: ./build/res/mipmap/icon.png  
 extracting: ./build/resources.arsc
```

## Building a native Android library with C

The link between our the C code and the Java code that drives all Android
apps is provided by
[`android_native_app_glue.h`](https://android.googlesource.com/platform/ndk/+/refs/heads/main/sources/android/native_app_glue/android_native_app_glue.h)
and
[`android_native_app_glue.c`](https://android.googlesource.com/platform/ndk/+/refs/heads/main/sources/android/native_app_glue/android_native_app_glue.c).
The glue exports
an `ANativeActivity_onCreate` function that is called through
the [Java Native Interface][21] on startup. This
function sets up callbacks to allow our C code to respond
to events from the Java thread(s), then uses [`pthread_create`][31] to
start a new thread that calls `android_main`. The
`android_main` function serves as our C entry point.

We will copy both glue source files into a new `src/` directory
and create a `src/main.c`. To begin, we will set up event callbacks,
then run a main loop that polls for events.

```c
/* src/main.c */

#include <android/log.h>
#include "android_native_app_glue.h"

#define SEGL_LOG_ID "SEGL"

static void handle_cmd(struct android_app *app, int32_t cmd) {
    switch (cmd) {
        case APP_CMD_INIT_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_INIT_WINDOW"
            );
            /* app window opened or resumed, create EGL context */
            break;
        case APP_CMD_TERM_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_TERM_WINDOW"
            );
            /* app window closed or paused, release EGL context */
            break;
        case APP_CMD_DESTROY:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_DESTROY"
            );
            /* app has been closed */
            break;
        default:
            break;
    }
}

static int32_t handle_input(struct android_app *app, AInputEvent *event) {
    /* handle touch and keyboard input */
    return 0;
}

void android_main(struct android_app *app) {
    __android_log_print(ANDROID_LOG_INFO, SEGL_LOG_ID, "android_main");
    app->onAppCmd = handle_cmd;
    app->onInputEvent = handle_input;
    /* app started, perform initial setup */
    for (;;) {
        int events;
        struct android_poll_source *source;
        for (;;) {
            int res = ALooper_pollOnce(0, 0, &events, (void **)&source);
            if (res < 0) {
                break;
            }
            if (source != NULL) {
                source->process(app, source);
            }
        }
        /* update state and draw to screen */
    }
}
```

We can now build the library and re-package the `.apk`. Recall that `clang`
will always refer to the binary distributed with the Android NDK.

```bash
$ mkdir -p ./build/lib/arm64-v8a
$ clang --target=aarch64-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/arm64-v8a/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ cd ./build
$ zip -D4r ../temp2.apk .
$ zip -D0r ../temp2.apk ./resources.arsc ./AndroidManifest.xml
$ cd ..
$ zipalign -v 4 ./temp2.apk ./seglapp.apk
$ keytool -genkey -v -keystore mykey.keystore -alias mykey \
    -keyalg RSA -keysize 2048 -validity 10000 \
    -storepass mypassword -keypass mypassword \
    -dname "CN=example.com, OU=ID, O=Example, L=Callar, S=Morvern, C=GB"
$ apksigner sign --key-pass pass:mypassword \
    --ks-pass pass:mypassword \
    --ks mykey.keystore \
    ./seglapp.apk
```

The number at the end of the `clang` target is the [minimum SDK version][22].
Above we defined a minimum version of 22 in our
`template/AndroidManifest.xml`.

Finally, we can install the `seglapp.apk` on an Android device.
The device in question must be connected over USB and have
[USB debugging enabled][18].

```
$ adb install seglapp.apk
```

If all went well, we should have an app named `seglapp`
on our device. It may be necessary to run `adb` under `sudo`,
or to `su` and run `adb` as root, depending on system and user permissions.

When we open the app, we are
met with a black screen: we haven't drawn anything
yet. What we have done, however, is printed some log messages.
The logs for everything happening on a connected device can be viewed with
`adb shell logcat`. That command will usually produce a deluge of information
which, while potentially helpful if piped to a file, is
of little use as command-line output. To view only logs produced
by our code, we can use [filters][6].

```bash
adb shell logcat SEGL:I *:S
```

The `SEGL:I` filter tells `logcat` to print messages tagged with `SEGL` that
have `ANDROID_LOG_INFO` priority or higher, while the `*:S` filter silences all
other log messages. Recall that our `__android_log_print` calls used the
tag `"SEGL"`.

Try running the above `logcat` command, then opening `seglapp` on your
Android device. Look at what log messages are printed when you open, minimize,
resume, and close the application. Below is the `logcat` output I see when
I tap on the app, swipe up to minimize it, open the app again, then
manually terminate it.

```bash
$ adb shell logcat SEGL:I *:S
07-24 14:37:19.206 25465 25484 I SEGL    : android_main
07-24 14:37:19.259 25465 25484 I SEGL    : APP_CMD_INIT_WINDOW
07-24 14:37:23.308 25465 25484 I SEGL    : APP_CMD_TERM_WINDOW
07-24 14:37:25.070 25465 25484 I SEGL    : APP_CMD_INIT_WINDOW
07-24 14:37:28.058 25465 25484 I SEGL    : APP_CMD_TERM_WINDOW
07-24 14:37:28.085 25465 25484 I SEGL    : APP_CMD_DESTROY
```

## Drawing graphics with EGL and OpenGL

There are two basic directions our build could take to access to the
[EGL][12] C API: link `libEGL.so` as shared library (with `-lEGL`),
or use [`dlopen`][11] to load it runtime. I prefer to
reduce build dependencies wherever possible, so we will
be going the `dlopen` route.

```c
/* src/main.c */

#include <android/log.h>
#include <android/native_window.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <time.h>
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include "android_native_app_glue.h"

#define SEGL_LOG_ID "SEGL"
#define TIMESTEP 16L * 1000L * 1000L

struct segl_vtable {
    PFNEGLCHOOSECONFIGPROC ChooseConfig;
    PFNEGLCREATECONTEXTPROC CreateContext;
    PFNEGLCREATEWINDOWSURFACEPROC CreateWindowSurface;
    PFNEGLDESTROYCONTEXTPROC DestroyContext;
    PFNEGLDESTROYSURFACEPROC DestroySurface;
    PFNEGLGETCONFIGATTRIBPROC GetConfigAttrib;
    PFNEGLGETCURRENTDISPLAYPROC GetCurrentDisplay;
    PFNEGLGETDISPLAYPROC GetDisplay;
    PFNEGLGETPROCADDRESSPROC GetProcAddress;
    PFNEGLINITIALIZEPROC Initialize;
    PFNEGLMAKECURRENTPROC MakeCurrent;
    PFNEGLSWAPBUFFERSPROC SwapBuffers;
    PFNEGLTERMINATEPROC Terminate;
};

static struct segl_vtable segl_vtable_load(void) {
    void *so_handle = dlopen("libEGL.so", RTLD_LAZY | RTLD_LOCAL);
    if (so_handle == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            "SEGLAP",
            "failed to load libEGL.so: %s",
            dlerror()
        );
        exit(1);
    }

    struct segl_vtable vtable = { 0 };
    vtable.ChooseConfig = dlsym(so_handle, "eglChooseConfig");
    if (vtable.ChooseConfig == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglChooseConfig: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.CreateContext = dlsym(so_handle, "eglCreateContext");
    if (vtable.CreateContext == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglCreateContext: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.CreateWindowSurface = dlsym(so_handle, "eglCreateWindowSurface");
    if (vtable.CreateWindowSurface == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglCreateWindowSurf: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.DestroyContext = dlsym(so_handle, "eglDestroyContext");
    if (vtable.DestroyContext == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglDestroyContext: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.DestroySurface = dlsym(so_handle, "eglDestroySurface");
    if (vtable.DestroySurface == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglDestroySurface: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetConfigAttrib = dlsym(so_handle, "eglGetConfigAttrib");
    if (vtable.GetConfigAttrib == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetConfigAttrib: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetCurrentDisplay = dlsym(so_handle, "eglGetCurrentDisplay");
    if (vtable.GetCurrentDisplay == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetCurrentDisplay: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetDisplay = dlsym(so_handle, "eglGetDisplay");
    if (vtable.GetDisplay == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetDisplay: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.GetProcAddress = dlsym(so_handle, "eglGetProcAddress");
    if (vtable.GetProcAddress == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglGetProcAddress: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.Initialize = dlsym(so_handle, "eglInitialize");
    if (vtable.Initialize == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglInitialize: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.MakeCurrent = dlsym(so_handle, "eglMakeCurrent");
    if (vtable.MakeCurrent == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglMakeCurrent: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.SwapBuffers = dlsym(so_handle, "eglSwapBuffers");
    if (vtable.SwapBuffers == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglSwapBuffers: %s",
            dlerror()
        );
        exit(1);
    }
    vtable.Terminate = dlsym(so_handle, "eglTerminate");
    if (vtable.Terminate == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load eglTerminate: %s",
            dlerror()
        );
        exit(1);
    }

    return vtable;
}

struct segl_ctx {
    EGLDisplay display;
    EGLConfig config;
    EGLContext context;
    EGLSurface surface;
};

static struct segl_ctx segl_ctx_load(
    struct android_app *app,
    struct segl_vtable *segl_vtable
) {
    struct segl_ctx segl_ctx;

    segl_ctx.display = segl_vtable->GetDisplay(EGL_DEFAULT_DISPLAY);
    if (segl_ctx.display == EGL_NO_DISPLAY) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to find EGL display"
        );
        exit(1);
    }

    EGLint major;
    EGLint minor;
    if (!segl_vtable->Initialize(segl_ctx.display, &major, &minor)) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to initialize EGL display"
        );
        exit(1);
    }

    /* NOTE: may wish to require an 8 bit alpha channel as well */
    const EGLint attribs[] = {
        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
        EGL_CONFORMANT, EGL_OPENGL_ES2_BIT,
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER,
        EGL_RED_SIZE, 8,
        EGL_GREEN_SIZE, 8,
        EGL_BLUE_SIZE, 8,
        EGL_NONE,
    };
    EGLint nconfigs;
    if (
        !segl_vtable->ChooseConfig(
            segl_ctx.display,
            attribs,
            &segl.config,
            1,
            &nconfigs
        ) ||
        nconfigs == 0
    ) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to find EGL config"
        );
        exit(1);
    }

    const EGLint context_attribs[] = {
        EGL_CONTEXT_MAJOR_VERSION, 2,
        EGL_CONTEXT_MINOR_VERSION, 0,
        EGL_NONE,
    };
    segl_ctx.context = segl_vtable->CreateContext(
        segl_ctx.display,
        segl_ctx.config,
        EGL_NO_CONTEXT,
        context_attribs
    );
    if (segl_ctx.context == EGL_NO_CONTEXT) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to create EGL context"
        );
        exit(1);
    }
    segl_ctx.surface = segl_vtable->CreateWindowSurface(
        segl_ctx.display,
        segl_ctx.config,
        app->window,
        NULL
    );
    if (segl_ctx.surface == EGL_NO_SURFACE) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to create EGL surface"
        );
        exit(1);
    }

    if (
        !segl_vtable->MakeCurrent(
            segl_ctx.display,
            segl_ctx.surface,
            segl_ctx.surface,
            segl_ctx.context
        )
    ) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to set EGL surface and context"
        );
        exit(1);
    }

    return segl_ctx;
}

static void segl_ctx_unload(
    struct segl_ctx *segl_ctx,
    struct segl_vtable *segl_vtable
) {
    if (segl_ctx->display == EGL_NO_DISPLAY) {
        return;
    }

    segl_vtable->MakeCurrent(
        segl_ctx->display,
        EGL_NO_SURFACE,
        EGL_NO_SURFACE,
        EGL_NO_CONTEXT
    );

    if (segl_ctx->context != EGL_NO_CONTEXT) {
        segl_vtable->DestroyContext(segl_ctx->display, segl_ctx->context);
    }

    if (segl_ctx->surface != EGL_NO_SURFACE) {
        segl_vtable->DestroySurface(segl_ctx->display, segl_ctx->surface);
    }

    segl_vtable->Terminate(segl_ctx->display);

    segl_ctx->display = EGL_NO_DISPLAY;
    segl_ctx->context = EGL_NO_CONTEXT;
    segl_ctx->surface = EGL_NO_SURFACE;
}

struct sgles2_vtable {
    PFNGLCLEARPROC Clear;
    PFNGLCLEARCOLORPROC ClearColor;
    PFNGLVIEWPORTPROC Viewport;
};

static struct sgles2_vtable sgles2_vtable_load(struct segl_vtable *segl_vtable) {
    struct sgles2_vtable vtable = { 0 };

    vtable.Clear = (PFNGLCLEARPROC)segl_vtable->GetProcAddress("glClear");
    if (vtable.Clear == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load glClear"
        );
        exit(1);
    }
    vtable.ClearColor = (PFNGLCLEARCOLORPROC)segl_vtable->GetProcAddress(
        "glClearColor"
    );
    if (vtable.ClearColor == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load glClearColor"
        );
        exit(1);
    }
    vtable.Viewport = (PFNGLVIEWPORTPROC)segl_vtable->GetProcAddress(
        "glViewport"
    );
    if (vtable.Viewport == NULL) {
        __android_log_print(
            ANDROID_LOG_ERROR,
            SEGL_LOG_ID,
            "failed to load glViewport"
        );
        exit(1);
    }

    return vtable;
}

static struct segl_vtable egl;
static struct segl_ctx egl_ctx;
static struct sgles2_vtable gl;

static void handle_cmd(struct android_app *app, int32_t cmd) {
    switch (cmd) {
        case APP_CMD_INIT_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_INIT_WINDOW"
            );
            if (egl_ctx.display != EGL_NO_DISPLAY) {
                break;
            }
            egl_ctx = segl_ctx_load(app, &egl);
            break;
        case APP_CMD_TERM_WINDOW:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_TERM_WINDOW"
            );
            if (egl_ctx.display == EGL_NO_DISPLAY) {
                break;
            }
            segl_ctx_unload(&egl_ctx, &egl);
            break;
        case APP_CMD_DESTROY:
            __android_log_print(
                ANDROID_LOG_INFO,
                SEGL_LOG_ID,
                "APP_CMD_DESTROY"
            );
            /* app has been closed */
            break;
        default:
            break;
    }
}

static int32_t handle_input(struct android_app *app, AInputEvent *event) {
    /* handle touch and keyboard input */
    return 0;
}

static int64_t time_since_ns(struct timespec end, struct timespec start) {
    int64_t seconds = (int64_t)end.tv_sec - (int64_t)start.tv_sec;
    int64_t sec_diff = seconds * 1000L * 1000L * 1000L;
    int64_t nsec_diff = (int64_t)end.tv_nsec - (int64_t)start.tv_nsec;
    return sec_diff + nsec_diff;
}

void android_main(struct android_app *app) {
    __android_log_print(ANDROID_LOG_INFO, SEGL_LOG_ID, "android_main");
    app->onAppCmd = handle_cmd;
    app->onInputEvent = handle_input;

    egl = segl_vtable_load();
    gl = sgles2_vtable_load(&egl);

    float red = 0.66f;
    bool red_flip = false;
    float green = 0.33f;
    bool green_flip = false;
    float blue = 0.0f;
    bool blue_flip = false;

    int64_t elapsed = 0;
    struct timespec last;
    clock_gettime(CLOCK_MONOTONIC, &last);
    for (;;) {
        struct timespec now;
        clock_gettime(CLOCK_MONOTONIC, &now);
        elapsed += time_since_ns(now, last);
        last = now;

        while (elapsed >= TIMESTEP) {
            red += 0.005f;
            green += 0.006f;
            blue += 0.007f;
            if (red >= 1.0f) {
                red -= 1.0f;
                red_flip = !red_flip;
            }
            if (green >= 1.0f) {
                green -= 1.0f;
                green_flip = !green_flip;
            }
            if (blue >= 1.0f) {
                blue -= 1.0f;
                blue_flip = !blue_flip;
            }
            elapsed -= TIMESTEP;
        }

        int events;
        struct android_poll_source *source;
        for (;;) {
            int res = ALooper_pollOnce(0, 0, &events, (void **)&source);
            if (res < 0) {
                break;
            }
            if (source != NULL) {
                source->process(app, source);
            }
        }

        if (egl_ctx.display == EGL_NO_DISPLAY) {
            const struct timespec duration = { .tv_nsec = TIMESTEP };
            nanosleep(&duration, NULL);
            continue;
        }

        int width = ANativeWindow_getWidth(app->window);
        int height = ANativeWindow_getHeight(app->window);

        gl.Viewport(0, 0, width, height);
        gl.ClearColor(
            red_flip ? 1.0f - red : red,
            green_flip ? 1.0f - green : green,
            blue_flip ? 1.0f - blue : blue,
            1.0f
        );
        gl.Clear(GL_COLOR_BUFFER_BIT);

        egl.SwapBuffers(egl_ctx.display, egl_ctx.surface);
    }
}
```

The `segl_vtable_load` function loads `libEGL.so`, then constructs a
[vtable][20]
containing each EGL 1.0 API function needed for this demo.
The `segl_ctx_load` function
uses the EGL vtable to create an OpenGL ES 2.0 context and
an EGL window surface corresponding to the Android app window.
The `segl_ctx_unload` function destroys the EGL context and
surface.

In order to draw anything, we'll need to load a second
vtable containing OpenGL functions.
The `sgles2_vtable_load` function loads such
a table using `GetProcAddress` from the EGL vtable.

**Note:** In a real project we should probably load the
full EGL 1.0 and OpenGL ES 2.0 APIs (or
whichever API versions we choose).

The loop in `android_main` clears the screen with a varying color.
The `handle_cmd` function loads an EGL context on
`APP_CMD_INIT_WINDOW` events, and destroys the context
on `APP_CMD_TERM_WINDOW` events.

**Note:** The `INIT_WINDOW`/`TERM_WINDOW` events are also
sent when the app is minimized/resumed, respectively.
When `TERM_WINDOW` is handled, it is important to maintain the
app state, but release
all OpenGL context data (shaders, textures, vertex buffers, etc.)
before the call to `segl_ctx_unload`. Then, when `INIT_WINDOW` is handled,
the OpenGL data must be re-constructed after `segl_ctx_load`.
Our application just clears the background, so we avoid
dealing with this.

Going through the same process as before, we can
compile our shared library, re-package `seglapp.apk`, and install
it on our device.

```bash
$ adb uninstall org.seglorg.seglapp
$ rm temp2.apk seglapp.apk
$ clang --target=aarch64-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/arm64-v8a/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ cd ./build
$ zip -D4r ../temp2.apk .
$ zip -D0r ../temp2.apk ./resources.arsc ./AndroidManifest.xml
$ cd ..
$ zipalign -v 4 ./temp2.apk ./seglapp.apk
$ apksigner sign --key-pass pass:mypassword \
    --ks-pass pass:mypassword \
    --ks mykey.keystore \
    ./seglapp.apk
$ adb install seglapp.apk
```

Running `seglapp` should now display a varying solid color
background which can be seamlessly suspended and resumed.

## Multi-architecture builds

The `seglapp.apk` we packaged above will only work on 64 bit ARM devices.
Fortunately, the process to package a `.apk` for multiple architectures
is very simple: add a separate sub-directory in `build/lib/` for
each architecture! For example, below
we add support for 32 bit ARM, x86, and x86_64.

```bash
$ mkdir -p ./build/lib/armeabi-v7a
$ clang --target=armv7a-linux-androideabi22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/armeabi-v7a/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ mkdir -p ./build/lib/x86
$ clang --target=i686-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/x86/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
$ mkdir -p ./build/lib/x86_64
$ clang --target=x86_64-linux-android22 \
    -Wall -Wextra -Wno-unused-parameter \
    -shared -fPIC -o ./build/lib/x86_64/libseglapp.so \
    ./src/main.c ./src/android_native_app_glue.c \
    -lm -ldl -landroid -llog
# then proceed with re-packaging as usual
```

The devices I own are all `aarch64`, but I've tested
other architectures with [emulators][30].

## Next steps

Our OpenGL example was very disappointing, we didn't even draw a triangle!
Loading the rest of the OpenGL ES API into the vtable, adding a basic
shader pipeline, and pushing some vertices to the GPU
should be priority number one.

We also haven't handled any input in our `handle_input` function,
the next step there is to
look at the Android NDK [input documentation][7].
We used the `ANativeWindow` API to get the width and height of the
application window, but there is [a lot more functionality available][10].
There are also a
few more `APP_CMD` events that may be useful, so it might be good
to read through the [native app glue docs][8] as well (and look
through the `android_native_app_glue.c` source file).

A finished version of the example in this article is available on [GitHub][9].

[1]: https://github.com/cnlohr/rawdrawandroid
[2]: https://github.com/permutationlock/libavengraph
[3]: https://github.com/HomuHomu833/android-sdk-custom
[4]: https://github.com/HomuHomu833/android-ndk-custom
[5]: https://github.com/Sable/android-platforms
[6]: https://developer.android.com/tools/logcat#filteringOutput
[7]: https://developer.android.com/ndk/reference/group/input
[8]: https://developer.android.com/reference/games/game-activity/group/android-native-app-glue
[9]: https://github.com/permutationlock/simple_android_egl_app
[10]: https://developer.android.com/ndk/reference/group/native-activity
[11]: https://www.man7.org/linux/man-pages/man3/dlopen.3.html
[12]: https://www.khronos.org/egl/
[13]: https://www.khronos.org/opengles/
[14]: https://openjdk.org/index.html
[15]: https://developer.android.com/studio
[16]: https://developer.android.com/ndk
[17]: https://musl.libc.org/
[18]: https://developer.android.com/studio/debug/dev-options
[19]: https://chimera-linux.org/
[20]: https://en.wikipedia.org/wiki/Virtual_method_table
[21]: https://en.wikipedia.org/wiki/Java_Native_Interface
[22]: https://developer.android.com/ndk/guides/other_build_systems#overview
[23]: https://developer.android.com/tools/releases/platform-tools
[24]: https://android.googlesource.com/platform/
[25]: https://android.googlesource.com/platform/prebuilts/fullsdk/platforms/+/refs/heads/main/
[26]: https://developer.android.com/tools/sdkmanager
[27]: https://jdk.java.net/24/
[28]: https://github.com/openjdk/jdk/blob/master/doc/building.md
[29]: https://developer.android.com/guide/topics/manifest/manifest-intro
[30]: https://developer.android.com/studio/run/emulator-commandline
[31]: https://www.man7.org/linux/man-pages/man3/pthread_create.3.html
[32]: https://github.com/openjdk/jdk/tree/master
[33]: https://developer.android.com/tools/aapt2
